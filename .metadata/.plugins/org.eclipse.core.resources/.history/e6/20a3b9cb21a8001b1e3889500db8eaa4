/*
 * Tivac_port.h
 *
 *  Created on: Apr 26, 2021
 *      Author: Lenovo PC
 */

#ifndef ROSSERIAL_ROSSERIAL_TIVAC_SRC_ROS_LIB_TIVAC_PORT_H_
#define ROSSERIAL_ROSSERIAL_TIVAC_SRC_ROS_LIB_TIVAC_PORT_H_

#define SYSTICKHZ  1000UL
extern volatile uint32_t g_ui32milliseconds;

class TivaCHardware
{
  public:
    TivaCHardware() {}

    void init()
    {

      this->ui32SysClkFreq = MAP_SysCtlClockGet();
      // Setup LEDs
      MAP_SysCtlPeripheralEnable(0x8|0x4|0x2);


      // Enable time keeping
      g_ui32milliseconds = 0;
      // Set up timer such that it produces one tick for each millisecond
      SysTickIntRegister(TivaCHardware::SystickIntHandler);
      MAP_SysTickPeriodSet(this->ui32SysClkFreq/SYSTICKHZ);
      MAP_SysTickEnable();
      MAP_SysTickIntEnable();

      // Enable the peripherals for UART0
//      MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
//      MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
//      // Set GPIO A0 and A1 as UART pins.
//      MAP_GPIOPinConfigure(GPIO_PA0_U0RX);
//      MAP_GPIOPinConfigure(GPIO_PA1_U0TX);
//      MAP_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
//      // Configure UART0
//      MAP_UARTConfigSetExpClk(UART0_BASE, this->ui32SysClkFreq, ROSSERIAL_BAUDRATE,
//          (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));
//      // Supposedely MCU resets with FIFO 1 byte depth. Just making sure.
//      MAP_UARTFIFODisable(UART0_BASE);
//      // UART buffers to transmit and receive
//      RingBufInit(&rxBuffer, this->ui8rxBufferData, RX_BUFFER_SIZE);
//      RingBufInit(&txBuffer, this->ui8txBufferData, TX_BUFFER_SIZE);
//
//      // Enable RX and TX interrupt
//      UARTIntRegister(UART0_BASE, TivaCHardware::UARTIntHandler);
//      IntEnable(INT_UART0);
//      MAP_UARTTxIntModeSet(UART0_BASE, UART_TXINT_MODE_EOT);
//      MAP_UARTIntEnable(UART0_BASE, UART_INT_RX | UART_INT_TX);

      // Enable processor interrupts.
      IntEnable(INT_UART0);
     IntMasterEnable();
    }

    // read a byte from the serial port. -1 = failure
    int read()
    {
      if (!RingBufEmpty(&rxBuffer))
        return RingBufReadOne(&rxBuffer);
      else
        return -1;
    }

    // write data to the connection to ROS
    void write(uint8_t* data, int length)
    {
      // Trigger sending buffer, if not already sending
      if (RingBufEmpty(&txBuffer))
      {
        RingBufWrite(&txBuffer, data, length);
        MAP_UARTCharPutNonBlocking(UART0_BASE, RingBufReadOne(&txBuffer));
      }
      else
      {
        RingBufWrite(&txBuffer, data, length);
      }
    }

    // returns milliseconds since start of program
    uint32_t time()
    {
      return g_ui32milliseconds;
    }

    // UART buffer structures
    uint8_t ui8rxBufferData[RX_BUFFER_SIZE];
    uint8_t ui8txBufferData[TX_BUFFER_SIZE];

    // UARD interrupt handler
    // For each received byte, pushes it into the buffer.
    // For each transmitted byte, read the next available from the buffer.
    static void UARTIntHandler()
    {
//      uint32_t ui32Status;
//      // Get the interrrupt status.
//      ui32Status = MAP_UARTIntStatus(UART0_BASE, true);
//      // Clear the asserted interrupts.
//      MAP_UARTIntClear(UART0_BASE, ui32Status);
//
//      // Since we are using no RX, or TX FIFO, only one char at a time for each interrupt call
//      // RX the next character from the UART and put it on RingBuffer.
//      // We should verify if buffer is not full. Let's assume not, for faster interrupt routine.
//      if (ui32Status & UART_INT_RX)
//        RingBufWriteOne(&rxBuffer, MAP_UARTCharGetNonBlocking(UART0_BASE));
//
//      // TX the next available char on the buffer
//      if (ui32Status & UART_INT_TX)
//        if (!RingBufEmpty(&txBuffer))
//          MAP_UARTCharPutNonBlocking(UART0_BASE, RingBufReadOne(&txBuffer));
    }

    // Timing variables and System Tick interrupt handler.
    static void SystickIntHandler()
    {
      ++g_ui32milliseconds;
    }

    // System frequency
    uint32_t ui32SysClkFreq;
    uint32_t getSysClkFreq(void)
    {
      return this->ui32SysClkFreq;
    }

    // Not really accurate ms delay. But good enough for our purposes.
    // For a more elaborate delay check out ``Energia/hardware/lm4f/cores/lm4f/wiring.c``
    void delay(uint32_t ms)
    {
      while (ms > 500)
      {
        MAP_SysCtlDelay(this->ui32SysClkFreq/3/SYSTICKHZ * 500);
        ms -= 500;
      }
      MAP_SysCtlDelay(this->ui32SysClkFreq/3/SYSTICKHZ * ms);
    }
};

#endif /* ROSSERIAL_ROSSERIAL_TIVAC_SRC_ROS_LIB_TIVAC_PORT_H_ */
